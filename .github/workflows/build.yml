# name: CI Pipeline - Build
on:
  workflow_call:
  #Trigger the workflow on push from the develop branch
  # label:
  #   types:
  #     - on-going work
  #     - test-only
  #     - sca-only
  #     - scan-only
  #     - test-only
  #     - buid-only
#   push:
#     branches:
#       - feature-*
#       - master
#       - develop
#     issues:
#       types: [synchronize, opened, reopened, labeled, unlabeled]

# jobs:
#   #Test's job
#   tests:
#     if: ${{ contains(github.event.*.labels.*.name, 'test-only') }}
#     name: Unit tests
#     #Run on Ubuntu using the latest version
#     runs-on: ubuntu-latest
#     #Job's steps
#     steps:
#       #Check-out your repository under $GITHUB_WORKSPACE, so your workflow can access it
#       - uses: actions/checkout@v1
#       #Set up JDK 11
#       - name: Set up JDK
#         uses: actions/setup-java@v1
#         with:
#           java-version: '11'
#       #Set up Maven cache
#       - name: Cache Maven packages
#         #This action allows caching dependencies and build outputs to improve workflow execution time.
#         uses: actions/cache@v1
#         with:
#           path: ~/.m2
#           key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
#           restore-keys: ${{ runner.os }}-m2
#       #Run Tests
#       - name: Run Tests
#         run: mvn -B test
#   #Sonar's Job
#   sonar:
#     #Depends on test's job
#     # needs: tests
#     if: ${{ contains(github.event.*.labels.*.name, 'sca-only') }}
#     name: SonarQube analysis
#     runs-on: ubuntu-latest
#     steps:
#       #Set up Maven cache
#       - name: Cache Maven packages
#         #This action allows caching dependencies and build outputs to improve workflow execution time.
#         uses: actions/cache@v1
#         with:
#           path: ~/.m2
#           key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
#           restore-keys: ${{ runner.os }}-m2
#       # Setup SonarQube server and run scan
#       - name: SonarQube Scan
#         uses: kitabisa/sonarqube-action@v1.1.0
#         with:
#           host: ${{ secrets.SONARQUBE_HOST }}
#           login: ${{ secrets.SONARQUBE_TOKEN }}

#   trivy:
#     #Depends on sonar's job
#     #needs: sonar
#     if: ${{ contains(github.event.*.labels.*.name, 'sast-only') }}
#     name: Trivy Check
#     runs-on: ubuntu-18.04
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v2

#       - name: Run Trivy vulnerability scanner in repo mode
#         uses: aquasecurity/trivy-action@master
#         with:
#           scan-type: 'fs'
#           ignore-unfixed: true
#           format: 'sarif'
#           output: 'trivy-results.sarif'
#           severity: 'CRITICAL'

#       - name: Upload Trivy scan results to GitHub Security tab
#         uses: github/codeql-action/upload-sarif@v1
#         with:
#           sarif_file: 'trivy-results.sarif'
jobs:
  #Build's job
  build:
    #Depends on trivy's job
    #needs: trivy
    # if: ${{ contains(github.event.*.labels.*.name, 'build-only') }}
    name: Build
    #Run on Ubuntu using the latest version
    runs-on: ubuntu-latest
    steps:
      #Check-out your repository under $GITHUB_WORKSPACE, so your workflow can access it
      - uses: actions/checkout@v1
      #Set up JDK 11
      - name: Set up JDK
        uses: actions/setup-java@v1
        with:
          java-version: '11'
      #Set up Maven cache
      - name: Cache Maven packages
        #This action allows caching dependencies and build outputs to improve workflow execution time.
        uses: actions/cache@v1
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2
      #Build the application using Maven
      - name: Build with Maven
        run: mvn -B package -DskipTests --file pom.xml
      #Build the application using Maven
      - name: Upload JAR
        #This uploads artifacts from your workflow allowing you to share data between jobs and store data once a workflow is complete.
        uses: actions/upload-artifact@v2
        with:
          #Set artifact name
          name: artifact
          #From this path
          path: target/data-0.0.1-SNAPSHOT.jar
  #Deploy's job
  # deploy:
  #   #Depends on build's job
  #   needs: build
  #   if: ${{ contains(github.event.*.labels.*.name, 'deploy') }}
  #   name: Deploy
  #   #Run on Ubuntu using the latest version
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Download JAR
  #       #Download the artifact which was uploaded in the build's job
  #       uses: actions/download-artifact@v2
  #       with:
  #         name: artifact
      #Deploy the artifact (JAR) into AWS Beanstalk
      # - name: Deploy to EB
      #   uses: einaregilsson/beanstalk-deploy@v13
      #   with:
      #     aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
      #     aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      #     aws_session_token: ${{ secrets.AWS_SESSION_TOKEN }}
      #     use_existing_version_if_available: false
      #     application_name: spring-boot-deploy
      #     environment_name: Springbootdeploy-env
      #     version_label: ${{github.SHA}}
      #     region: us-east-1
      #     deployment_package: data-0.0.1-SNAPSHOT.jar